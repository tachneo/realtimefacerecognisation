import os
import shutil
import cv2
import face_recognition
import sqlite3
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import numpy as np
import tensorflow as tf
import tensorflow_hub as hub
import threading

# Ensure the necessary directories exist
os.makedirs("train_images", exist_ok=True)
os.makedirs("identified_images", exist_ok=True)

# Database setup
def init_db():
    conn = sqlite3.connect('object_recognition.db')
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS objects (
            id INTEGER PRIMARY KEY,
            name TEXT,
            category TEXT,
            image_path TEXT
        )
    ''')
    conn.commit()
    conn.close()

# Load the MobileNetV2 model from TensorFlow Hub
model = tf.keras.Sequential([
    hub.KerasLayer("https://tfhub.dev/google/tf2-preview/mobilenet_v2/classification/4",
                   trainable=True, arguments=dict(batch_norm_momentum=0.997))
])
model.build([None, 224, 224, 3])  # Batch input shape.

# GUI application
class ObjectRecognitionApp:
    def __init__(self, master):
        self.master = master
        self.master.title("Object Recognition System")
        self.master.configure(bg='#4A7A8C')

        self.capture = None
        self.current_frame = None
        self.known_faces = self.load_known_faces()
        self.known_objects = self.load_known_objects()

        # Camera stream URL
        self.camera_url = "http://192.168.1.6:8080/video"

        self.create_widgets()

        # Thread for capturing frames
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target=self.update_frame, args=())
        self.thread.start()

    def create_widgets(self):
        self.title_label = tk.Label(self.master, text="Object Recognition System", bg='#4A7A8C', fg='white', font=('Helvetica', 16, 'bold'))
        self.title_label.pack(pady=10)

        self.start_button = tk.Button(self.master, text="Start Camera", command=self.start_camera, bg='#5C8D99', fg='white', font=('Helvetica', 12, 'bold'))
        self.start_button.pack(pady=5)

        self.stop_button = tk.Button(self.master, text="Stop Camera", command=self.stop_camera, bg='#5C8D99', fg='white', font=('Helvetica', 12, 'bold'))
        self.stop_button.pack(pady=5)

        self.capture_button = tk.Button(self.master, text="Capture & Add Object", command=self.capture_and_add_object, bg='#5C8D99', fg='white', font=('Helvetica', 12, 'bold'))
        self.capture_button.pack(pady=5)

        self.entry_button = tk.Button(self.master, text="Enter New Object Manually", command=self.enter_object_manually, bg='#5C8D99', fg='white', font=('Helvetica', 12, 'bold'))
        self.entry_button.pack(pady=5)

        self.canvas = tk.Canvas(self.master, width=800, height=600, bg='#B4D7E1')
        self.canvas.pack(pady=10)

    def load_known_faces(self):
        known_faces = {}
        for filename in os.listdir("train_images"):
            if filename.endswith(".jpg") or filename.endswith(".png"):
                image_path = os.path.join("train_images", filename)
                image = face_recognition.load_image_file(image_path)
                encodings = face_recognition.face_encodings(image)
                if encodings:
                    encoding = encodings[0]
                    label = os.path.splitext(filename)[0]
                    known_faces[label] = encoding
        return known_faces

    def load_known_objects(self):
        known_objects = {}
        conn = sqlite3.connect('object_recognition.db')
        c = conn.cursor()
        for row in c.execute("SELECT name, category, image_path FROM objects"):
            name, category, image_path = row
            known_objects[name] = {
                'category': category,
                'image': cv2.imread(image_path)
            }
        conn.close()
        return known_objects

    def start_camera(self):
        self.capture = cv2.VideoCapture(self.camera_url)
        self.stop_event.clear()

    def stop_camera(self):
        if self.capture:
            self.capture.release()
            self.capture = None
        self.stop_event.set()

    def update_frame(self):
        while not self.stop_event.is_set():
            if self.capture:
                ret, frame = self.capture.read()
                if ret:
                    self.current_frame = frame
                    # Resize frame to increase view area
                    frame = cv2.resize(frame, (800, 600))
                    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    small_frame = cv2.resize(rgb_frame, (224, 224)) / 255.0

                    # Run the MobileNetV2 model
                    predictions = model.predict(np.expand_dims(small_frame, axis=0))
                    predicted_class = np.argmax(predictions[0])

                    # Add object detection boxes and labels
                    self.draw_boxes(frame, predicted_class)

                    img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    img = Image.fromarray(img)
                    img_tk = ImageTk.PhotoImage(image=img)
                    self.canvas.create_image(0, 0, anchor=tk.NW, image=img_tk)
                    self.canvas.image = img_tk
            else:
                self.stop_event.wait(1)

    def draw_boxes(self, frame, predicted_class):
        # Assuming predicted_class is an index, you need to map it to the actual label
        # Here we just print the class index. You should replace this with the actual label.
        label = f"Class {predicted_class}"
        cv2.putText(frame, label, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

    def save_unknown_image(self, frame, encoding=None):
        unknown_count = len(os.listdir("identified_images")) + 1
        filename = f"identified_images/unknown_{unknown_count}.jpg"
        cv2.imwrite(filename, frame)

        if encoding is not None:
            self.enter_object(encoding)

    def capture_and_add_object(self):
        if self.current_frame is not None:
            filename = filedialog.asksaveasfilename(defaultextension=".jpg", filetypes=[("JPEG files", "*.jpg"), ("All files", "*.*")])
            if filename:
                cv2.imwrite(filename, self.current_frame)
                self.enter_object_manually(filename)

    def enter_object(self, encoding=None):
        new_window = tk.Toplevel(self.master)
        new_window.title("Enter New Object")

        tk.Label(new_window, text="Object Name").grid(row=0)
        tk.Label(new_window, text="Category").grid(row=1)
        tk.Label(new_window, text="Image").grid(row=2)

        name_entry = tk.Entry(new_window)
        category_entry = tk.Entry(new_window)
        image_entry = tk.Entry(new_window)

        name_entry.grid(row=0, column=1)
        category_entry.grid(row=1, column=1)
        image_entry.grid(row=2, column=1)

        def select_image():
            file_path = filedialog.askopenfilename()
            image_entry.delete(0, tk.END)
            image_entry.insert(0, file_path)

        select_image_button = tk.Button(new_window, text="Browse", command=select_image)
        select_image_button.grid(row=2, column=2)

        def save_object():
            name = name_entry.get()
            category = category_entry.get()
            image_path = image_entry.get()

            # Save the image to train_images directory
            new_image_path = os.path.join("train_images", os.path.basename(image_path))
            shutil.copy(image_path, new_image_path)

            conn = sqlite3.connect('object_recognition.db')
            c = conn.cursor()
            c.execute("INSERT INTO objects (name, category, image_path) VALUES (?, ?, ?)", (name, category, new_image_path))
            conn.commit()
            conn.close()

            if encoding is not None:
                self.known_faces[name] = encoding

            self.known_objects[name] = {
                'category': category,
                'image': cv2.imread(new_image_path)
            }

            messagebox.showinfo("Success", "Object entry saved successfully!")
            new_window.destroy()

        save_button = tk.Button(new_window, text="Save", command=save_object)
        save_button.grid(row=3, columnspan=3)

    def enter_object_manually(self, image_path=None):
        new_window = tk.Toplevel(self.master)
        new_window.title("Enter New Object")

        tk.Label(new_window, text="Object Name").grid(row=0)
        tk.Label(new_window, text="Category").grid(row=1)
        tk.Label(new_window, text="Image").grid(row=2)

        name_entry = tk.Entry(new_window)
        category_entry = tk.Entry(new_window)
        image_entry = tk.Entry(new_window)

        name_entry.grid(row=0, column=1)
        category_entry.grid(row=1, column=1)
        image_entry.grid(row=2, column=1)

        if image_path:
            image_entry.insert(0, image_path)

        def select_image():
            file_path = filedialog.askopenfilename()
            image_entry.delete(0, tk.END)
            image_entry.insert(0, file_path)

        select_image_button = tk.Button(new_window, text="Browse", command=select_image)
        select_image_button.grid(row=2, column=2)

        def save_object():
            name = name_entry.get()
            category = category_entry.get()
            image_path = image_entry.get()

            # Save the image to train_images directory
            new_image_path = os.path.join("train_images", os.path.basename(image_path))
            shutil.copy(image_path, new_image_path)

            conn = sqlite3.connect('object_recognition.db')
            c = conn.cursor()
            c.execute("INSERT INTO objects (name, category, image_path) VALUES (?, ?, ?)", (name, category, new_image_path))
            conn.commit()
            conn.close()

            self.known_objects[name] = {
                'category': category,
                'image': cv2.imread(new_image_path)
            }

            messagebox.showinfo("Success", "Object entry saved successfully!")
            new_window.destroy()

        save_button = tk.Button(new_window, text="Save", command=save_object)
        save_button.grid(row=3, columnspan=3)

if __name__ == "__main__":
    init_db()
    root = tk.Tk()
    app = ObjectRecognitionApp(root)
    root.mainloop()
